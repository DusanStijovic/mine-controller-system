RoomModel PumpModel {

	import etrice.api.types.*
	import WaterTankModel.DrainWater
	import etrice.api.timer.PTimer
	import PoolingSensorModel.PoolingSensorCommands
	import EnvironmentModel.supstanceLevelEvent
	import InterrupSensorModel.EventHappened

	ActorClass PumpControlStation {
		Interface {
			conjugated Port highWaterSensor: EventHappened
			conjugated Port lowWaterSensor: EventHappened
			Port controlMotor: PumpMotorControll
			Port waterFlowSensor: PoolingSensorCommands
			conjugated Port methaneLevel: supstanceLevelEvent
			conjugated Port alarmSender: AlarmModel.AlarmSender
			conjugated Port messageSender: ConsoleModel.MessagingProtocol
		}
		Structure {
			usercode1 '''
				import java.util.Date;
				import java.util.Calendar;
			'''
			usercode2 '''
				private boolean isPumpActive = false;
				private int MAX_ERROR_COUNT = 2;
				private boolean shouldGetFlow = false;
				private int errorCount = 0;
				private int numberOfSameMeasure = 0;
				private static int PERIOD_OF_ACTIVATION_MS = 100;
				private static int NUM_OF_NEEDED_MEASURE = 11;
				private static int PERIOD_OF_CHECKING_DEVICE = 50;
				private boolean highDetected = false;
				private boolean lowDetected = false;
				private  boolean highMethaneDetected = false;
				private boolean inProcess = false;
				private long waterSensorActivationInMs = 0;
				
				private int calculateWaitTime(long nextActivationInMs){
					long waitTime = nextActivationInMs - Calendar.getInstance().getTimeInMillis();
					waitTime = Math.max(waitTime, 1);
					return (int)waitTime;
				}
				
			'''
			external Port lowWaterSensor
			external Port highWaterSensor
			external Port controlMotor
			external Port waterFlowSensor
			SAP timingService: PTimer
			external Port methaneLevel
			external Port alarmSender
			external Port messageSender
		}
		Behavior {
			StateMachine {
				State startCheckingPumpState {
					entry '''
						waterSensorActivationInMs += PERIOD_OF_ACTIVATION_MS;
						if (!inProcess){
						    if (highDetected){
						        highDetected = false;
						        inProcess = true;
						        System.out.println("Usao high nakon provere");
						        inProcess = true;
						        controlMotor.turnOnPump();
						        isPumpActive = true;
						        numberOfSameMeasure = 0;
						        shouldGetFlow = false;
						        timingService.kill();
						        timingService.startTimeout(calculateWaitTime(waterSensorActivationInMs));
						    } else if (lowDetected){
						        lowDetected = false;
						        inProcess = true;
						        System.out.println("Usao low nakon provere");
						        controlMotor.turnOffPump();
						        isPumpActive = false;
						        numberOfSameMeasure = 0;
						        shouldGetFlow = false;
						        timingService.kill();
						        timingService.startTimeout(calculateWaitTime(waterSensorActivationInMs));
						    } else if (highMethaneDetected){
						        highMethaneDetected = false;
						        inProcess = true;
						        System.out.println("Usao high metan nakon provere");
						        controlMotor.turnOffPump();
						        isPumpActive = false;
						        numberOfSameMeasure = 0;
						        shouldGetFlow = false;
						        timingService.kill();
						        timingService.startTimeout(calculateWaitTime(waterSensorActivationInMs));
						    } else {
						        inProcess = true;
						        // System.out.println("Normalna provera");
						        shouldGetFlow = true;
						        timingService.kill();
						        waterFlowSensor.startADConverstion();
						        timingService.startTimeout(calculateWaitTime(waterSensorActivationInMs));
						        // System.out.println("Posalji status odbirka");
						    }
						} else {              
						    if (numberOfSameMeasure <= NUM_OF_NEEDED_MEASURE){
						        shouldGetFlow = false;
						        numberOfSameMeasure++;
						        timingService.kill();
						        timingService.startTimeout(calculateWaitTime(waterSensorActivationInMs));
						       // System.out.println("ne racunaj jos uvek");
						    } else {
						        System.out.println("Usao u proveru");
						        numberOfSameMeasure = 0;
						        shouldGetFlow = true;
						        timingService.kill();
						        waterFlowSensor.startADConverstion();
						        timingService.startTimeout(calculateWaitTime(waterSensorActivationInMs));
						        System.out.println("Posalji status odbirka");
						    }
						}
					'''
				}

				State askForStatus {
					entry '''
						waterFlowSensor.readStatus();
					'''
				}
				State statusGet {
				}

				Transition initialTimeOut: startCheckingPumpState -> startCheckingPumpState {
					triggers {
						<timeout: timingService guard '''!shouldGetFlow'''>
					}
				}
				Transition tr1: startCheckingPumpState -> askForStatus {
					triggers {
						<timeout: timingService guard '''shouldGetFlow'''>
					}
				}
				Transition t: askForStatus -> statusGet {
					triggers {
						<sendStatus: waterFlowSensor>
					}
					action '''
						int status = transitionData;
						System.out.println("Dobijanje statusa");
						
						if (status == PoolingSensorCommands.Status.NOT_READY.ordinal()){
								timingService.startTimeout(PERIOD_OF_CHECKING_DEVICE);
								System.out.println("Not ready");
						}
						if (status == PoolingSensorCommands.Status.ERROR.ordinal()){
							System.out.println("Error while geting water flow");
							errorCount++;
							if (errorCount >= MAX_ERROR_COUNT){
								System.out.println("Too mutch errors while getting flow");
								errorCount = 0;
								alarmSender.alarmErrorReadingWaterFlow();
							}
							waterFlowSensor.readErrorRegister();	
						}
						if (status == PoolingSensorCommands.Status.READY.ordinal()){
							errorCount = 0;
						 	waterFlowSensor.readValueRegister();
						}
					'''
				}
				Transition tr0: statusGet -> askForStatus {
					triggers {
						<timeout: timingService>
					}
				}

				Transition tr6: startCheckingPumpState -> startCheckingPumpState {
					triggers {
						<eventHappened: lowWaterSensor>
					}
					action '''lowDetected = true;'''
				}

				Transition tr8: startCheckingPumpState -> startCheckingPumpState {
					triggers {
						<eventHappened: highWaterSensor>
					}
					action '''highDetected = true;'''
				}
				Transition tr9: startCheckingPumpState -> startCheckingPumpState {
					triggers {
						<highLevel: methaneLevel>
					}
					action '''highMethaneDetected = true;'''
				}

				Transition tr11: statusGet -> startCheckingPumpState {
					triggers {
						<sendValueRegister: waterFlowSensor>
					}
					action '''
						double waterFlow = transitionData;
						System.out.println("WaterFlow: " + waterFlow);
						if (isPumpActive && waterFlow == 0){
						    alarmSender.alarmErrorStartingPump();
						    System.out.println("Poslat zahtev za aktiviranje pumpe, a protok vode ne postoji");
						}
						if (!isPumpActive && waterFlow != 0){
						    alarmSender.alarmErrorStoppingPump();
						    System.out.println("Poslat zahtev za gasenje pumpe, a protok vode postoji");
						}
						if (isPumpActive && waterFlow != 0){
						    System.out.println("Pumpa radi i protoka ima");
						}
						if (!isPumpActive && waterFlow == 0){
						    System.out.println("Pumpa ne radi  i nema protoka");
						}
						inProcess = false;'''
				}
				Transition tr2: statusGet -> startCheckingPumpState {
					triggers {
						<sendErrorRegister: waterFlowSensor>
					}
					action '''inProcess = false;'''
				}
				Transition tr3: startCheckingPumpState -> startCheckingPumpState {
					triggers {
						<normalLevel: methaneLevel>
					}
					action '''highMethaneDetected = false;'''
				}
				Transition init0: initial -> startCheckingPumpState {
				}
			}
		}
	}

	ActorClass PumpMotor {

		Interface {
			conjugated Port controlMotor: PumpMotorControll
			Port drainWater: DrainWater
		}
		Structure {
			usercode2 '''
				private static double WATER_DRAIN_ML_PER_MS = 10;
				private static int MOTOR_CHANGE_MODE_TIME_MS = 900;
				private static int SLEEEP_TIME_IN_MS = 10;
				private int timeElapsedToTurnOf = 0;
				private boolean shouldChangeToTurnOff = false;
				
				
				private boolean shouldIgnoreCommand(){
					boolean ignore =  Math.random() > 0.7;
					if (ignore){
						System.out.println("Ignorisana komanda");
					}
					return ignore;
				}
			'''
			external Port controlMotor
			external Port drainWater
			SAP timingService: PTimer
		}
		Behavior {
			StateMachine {
				State initState {
					entry '''					'''
				}
				State motorTurnOn
				State motorTurnOff {
					entry '''
						//					System.out.println("Motor se iskljucuje");
					'''
				}
				Transition init0: initial -> initState
				Transition tr0: initState -> motorTurnOn {
					triggers {
						<turnOnPump: controlMotor>
					}
					action '''
						timingService.kill();
						timingService.startTimeout(MOTOR_CHANGE_MODE_TIME_MS);
					'''
				}
				Transition tr1: initState -> motorTurnOff {
					triggers {
						<turnOffPump: controlMotor>
					}
					action '''
						timingService.kill();
						timingService.startTimeout(MOTOR_CHANGE_MODE_TIME_MS);
					'''
				}
				Transition tr2: motorTurnOff -> motorTurnOn {
					triggers {
						<turnOnPump: controlMotor guard '''!shouldIgnoreCommand()'''>
					}
					action '''
						timingService.kill();
						timingService.startTimeout(MOTOR_CHANGE_MODE_TIME_MS);
					'''
				}
				Transition tr3: motorTurnOn -> changeModeFromOnToOff {
					triggers {
						<turnOffPump: controlMotor>
					}
					action '''
						timeElapsedToTurnOf = 0;
						shouldChangeToTurnOff = false;
						timingService.kill();
						timingService.startTimeout(SLEEEP_TIME_IN_MS);
					'''
				}
				Transition tr4: motorTurnOn -> motorTurnOn {
					triggers {
						<timeout: timingService>
					}
					action '''
						drainWater.drainWater(WATER_DRAIN_ML_PER_MS * SLEEEP_TIME_IN_MS);
						timingService.kill();
						timingService.startTimeout(SLEEEP_TIME_IN_MS);
					'''
				}
				State changeModeFromOnToOff
				Transition tr5: changeModeFromOnToOff -> changeModeFromOnToOff {
					triggers {
						<timeout: timingService guard '''!shouldChangeToTurnOff'''>
					}
					action '''
						timingService.kill();
						timingService.startTimeout(SLEEEP_TIME_IN_MS);
						timeElapsedToTurnOf += SLEEEP_TIME_IN_MS;
						drainWater.drainWater(WATER_DRAIN_ML_PER_MS * SLEEEP_TIME_IN_MS);
						if (timeElapsedToTurnOf == MOTOR_CHANGE_MODE_TIME_MS){
							shouldChangeToTurnOff = true;
						}
					'''
				}
				Transition tr6: changeModeFromOnToOff -> motorTurnOff {
					triggers {
						<timeout: timingService guard '''shouldChangeToTurnOff'''>
					}
				}
				Transition tr7: changeModeFromOnToOff -> motorTurnOn {
					triggers {
						<turnOnPump: controlMotor>
					}
					action '''
						timingService.kill();
						timingService.startTimeout(MOTOR_CHANGE_MODE_TIME_MS);
					'''
				}
			}
		}
	}

	ProtocolClass PumpMotorControll {
		outgoing {
			Message turnOnPump()
			Message turnOffPump()
		}
	}
}